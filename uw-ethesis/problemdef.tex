In this section, we first illustrate the terminology and notations adopted in this work. Then we formally define the problem of efficient OLAP query processing. 

%----------------------------------------------------------------------
\section{Terminologies}
%----------------------------------------------------------------------

This section gives definations and notations of property graph, queries, materializations. Besides, we introduce concepts of ``cuboid'' and ``subsubstrcutre'', which are two types of materializaitons we will use in our solution. 

\subsection{Defination of Property Graph}
We define a property graph as $G(V, Vid, E, Eid, A, L, f)$ where
\begin{itemize} 
\item $V$ is a set of nodes. $Vid$ is set of unique IDs of $V$.
\item $E$ is a set of edges. $E \subseteq V * V$. $Eid$ is set of unique IDs of $E$.
\item $A$ is a set of properties.
\item $L$ is a set of labels.
\item $f$ is mapping function that maps $V$ and $E$ to $A$, $L$, $Vid$ and $Eid$. 

$f_{VA}: \{V_{i} \rightarrow A_{i}\}, V_{i}\in V, A_{i} \subseteq A$ , maps each node to its properties.

$f_{VL}: \{V_{i} \rightarrow L_{i}\}, V_{i}\in V, L_{i} \subseteq L$ , maps each node to its labels.

$f_{EA}: \{E_{i} \rightarrow A_{i}\}, E_{i}\in E, L_{i} \subseteq A$ , maps each edge to its properties.

$f_{EA}: \{E_{i} \rightarrow L_{i}\}, E_{i}\in E, L_{i} \subseteq L$ , maps each edge to its labels.

$f_{VID}: \{V_{i} \rightarrow Vid_{i}\}, V_{i}\in V, Vid_{i} \subseteq N$ , maps each node to its unique ID.

$f_{EID}: \{E_{i} \rightarrow Eid_{i}\}, V_{i}\in V, Eid_{i} \subseteq N$ , maps each edge to its unique ID.

\end{itemize} 

\subsection{Notations on OLAP Query}

As discussed before, Four elements of a graph OLAP query are \textit{Structure}, \textit{Dimension}, \textit{Measure}, and \textit{Slicing Condition}(optional). We will introduce how we represent these four elements and an OLAP query. We will use Query \#3 in Chapter 2 as an example.

\textbf{\textit{Structure:}} A \textit{strucuture} consists of \textit{edges}. We write a \textit{structure} by listing all its \textit{edges} seperated by comma, where an \textit{edge} is represented by 

\fbox{
	\textit{Starting Node Label- Edge Label- Ending Node Label} 
}

For instance, Query \#3's \textit{structure} as shown in \ref{fig:2:3} is written as 

\textit{``User-owns-Post, Post-has-Tag''}



\textbf{\textit{Dimension:}} A
\textit{Dimension} is written by listing all properties that act as dimensions in an OLAP query.

Query \#3's \textit{dimension} is written as

\textit{``Tag.Tagname''}

\textbf{\textit{Measure:}} We focus on three most common types of \textit{measure}: \textit{COUNT(*), SUM and AVG. }

Query \#3's \textit{measure} is written as

\textit{``AVG(User.Age)''}


\textbf{\textit{Slicing Conditions:}} A \textit{Slicing Conditions} is written as 

\fbox{
$Property = value$
}

Query \#3's \textit{slicing conditions} is written as

\textit{``Post.Year=2017''}

\textbf{\textit{OLAP query:}} With the four elements ready, we write an entire OLAP query as 

\fbox{
	\textbf{\textit{Structure : Dimension, Measure, Slicing Condition}}
}

Query \#3 is written as 

fbox{
\textit{User-owns-Post, Post-has-Tag: Tag.Tagname, AVG(User.Age), Post.Year=2017
}

where \textit{User-owns-Post, Post-has-Tag} referring to  \textit{structure}, \textit{Tag.Tagname} referring to \textit{dimension},\textit{ AVG(User.Age) } referring to \textit{measure}, {Post.Year=2017} referring to \textit{slicing condition}. Note that since \textit{dimension}, \textit{measure} and \textit{slicing condition} are written in different forms, it is easy to distinguish them even if they are all listed together.


 \textbf{\textit{Features of a query:}} For a query q, we use ``q.properties'' to refer to a set of \textbf{all properties} in \textit{Dimension, Measure, and Slicing Condition} of q. We use ``q.structure'' to refer to structure of q.

 \textit{Query \#3.properties=\{Tag.Tagname, User.Age, Post.Year\}}
 
 \textit{q.structure= User-owns-Post, Post-has-Tag}



\subsection{Materialization: Cuboid vs Substructures}

We want to accerlerate OLAP by materializations from previous workload. We use

\fbox{
	\textbf{\textit{\$Query}} 
}

to refer to materializaiton of a $Query$.

As we mentioned before, in a property graph each node and edge has a unique ID, which can be treated as a special property. Whether a materialization keeps unique ID is an important issue, as keeping unique ID often increases space cost of a materialization. We categorize two types of materializaitons, ``cuboid'' and ``substructure'', based on whether unique IDs of nodes and(or) edges are kept or not. To better understand ``cuboid'' and ``substructure'', let's look at the following example.


Suppose we have following previous workload and future workload:

Previous workload \#1 User-owns-Post: User.Age\\
Previous workload \#2 User-owns-Post: User.Age, (AVG)Post.Score\\
Future workload \#1 User-owns-Post: (AVG)User.Age, Post.Score	\\
Future workload \#2 User-owns-Post, Post-has-Tag: User.Age, Tag.TagName




%User-owns-Post: User.Age
%
%User-owns-Post: User.Age, (AVG)Post.Score
%
%User-owns-Post, Post-has-Tag: User.Age, Tag.TagName

We can tell that the user is most interested in  \textit{User-owns-Post} structure. \{User.Age, Post.Score\} is the set of properties that are involved in queries over \textit{User-owns-Post} . We can build a cuboid lattice of all combinations of  \{User.Age, Post.Score\}. Materialization of base cuboid of the lattice is

\fbox{
\textit{\$User-owns-Post: User.Age, Post.Score, COUNT(*)}
}

\textit{\$User-owns-Post: User.Age, Post.Score, COUNT(*)} is useful for future workload \#1. We can process future workload \#1 by aggregation over \textit{\$User-owns-Post: User.Age, Post.Score, COUNT(*)}. We call such materilization a \textbf{``cuboid''}.


However, \textit{\$User-owns-Post: User.Age, Post.Score, COUNT(*)} is not useful for future workload \#2. The reason is that they have different \textit{structures}.


If we add ID(Post) into \textit{dimension} and materialize \textit{\$User-owns-Post: User.Age, Post.Score, ID(Post) COUNT(*)}, \textit{Post} is ``activated'' to be able to join with other materializations containing \textit{Post} and produce results for OLAP over more complicated \textit{structures}. For instance, future workload \#2 can be processed by 


1.joining \textit{\$User-owns-Post: User.Age, Post.Score, ID(Post) COUNT(*)} and \textit{\$Post-has-Tag: ID(Post), Tag.TagName, COUNT(*)} on ID(Post)

2.aggregation on \{User.Age, Tag.TagName\}. 

In this case, we only need to fetch \textit{\$Post-has-Tag: ID(Post), Tag.TagName, COUNT(*)} from database to produce result for future workload \#2. We call such materialization with ID(s) in \textit{dimension} \textbf{``substructure''}. 

Note that cuboids can only be used in queries with exactly the same structure. They can be be scanned for more aggregated dimension combinations(drill-down operations) but they are not useful for queries with different \textit{structures}. 

Substructures can be used to join with other materializations to help with future queries of various types of \textit{structures}.
The drawback is that structures are generally more space-costly than cuboids, as IDs are unique keys. The trade-off between cuboids and substructures is \textbf{\textit{space vs joining potential}}.

\ref{Table:3:1} gives a summary of comparisions between ``cuboid'' and ``substructure''. 

 \begin{table}
	\footnotesize
\begin {center}
\begin{tabular}{ | l | l | l |}
	\hline
 &Cuboid&Substructure\\ \hline
 Dimension& Only properties& Properties and ID(s)\\ \hline
 Space Cost& ``Low''&``High''\\ \hline
 Potential benefit& Aggregation& Aggregation \& Joining\\ \hline
\end{tabular}
\end {center}
\caption{Comparisons between Cuboid and Substructure.}
\label{Table:3:1}
\end{table}


%----------------------------------------------------------------------
\section{Problem Definition}
%----------------------------------------------------------------------

Our target is to faster process future OLAP workload using materializations computed based on previous workload. We can divide our goal in two steps. 
\begin{itemize}
	\item Materializaiton Step: clever selection of views for materialization. 
	\item Query Processing Step: processing future queries in shortest time(using materializaitons). 
\end{itemize} 

Materializaiton Step requires us to solve ``Materialization Selection Problem''. Query Processing Step requires us to solve ``Processing Plan Problem''. We give definations for these two problems as follows.

\textbf{``Materialization Selection Problem'':}

Using materialization is good for query efficiency, but comes with a storage cost. So we want to study the problem of how to best utilize materialization within a space budget limit $\sigma$. 


\\
We define ``Materialization Selection Problem'' as

Given a property graph dataset G, a set of previous queires P on G, space limit $\sigma$, find cuboids C and substructures S, $\displaystyle{\sum_{c_{i}\in C}c_{i}.space} + 
\displaystyle{\sum_{s_{i}\in S}s_{i}.space} 
\leq \sigma
$, so that $\displaystyle{\sum_{p_{i}\in P}estimatedProcessingTime(G, p_{i}, C, S)}$  is minimized.

Here $estimatedProcessingTime(p_{i}, C, S)}$ is a function for estimation of query processing time of $p_{i}$ on G using materializations of C and S.

%Is ``Processing Plan Problem'' even considered as a problem?
 
\textbf{``Processing Plan Problem'':}

We define ``Processing Plan Problem'' as


Given a property graph dataset G, a future query q, materialized cuboids C and substructures S, find a processing plan $process(G, q, C, S)$, so that $process(G, q, C, S).executionTime$ is minimized.
